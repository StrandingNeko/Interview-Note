# 1 基本输入输出练习

[牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/5652#question)

## 1.1 A+B(1)

计算a+b

数据范围： 数据组数$1≤t≤100$，数据大小满足 $1≤n≤1000$
输入描述:

```
输入包括两个正整数a,b(1 <= a, b <= 1000),输入数据包括多组。
```

输出描述:

```
输出a+b的结果
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int m, n;
	while(cin >> m >> n)
	{
		cout << m + n << endl;
	}
	return 0;
}
```

## 1.2 A+B(2)

计算a+b

数据范围：数据组数满足$1 <= t <= 100$，数据大小满足 $1 <= a, b <= 1000$

输入描述:

```
输入第一行包括一个数据组数t(1 <= t <= 100)
接下来每行包括两个正整数a,b(1 <= a, b <= 1000)
```

输出描述:

```
输出a+b的结果
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int line_num(0);
	int m(0), n(0);
	
	cin >> line_num;
	while(line_num--)
	{
		cin >> m >> n;
		cout << m + n << endl;
	}

	return 0;
}
```

## 1.3 A+B(3)

计算a+b

数据范围：数据组数满足$1≤t≤100$，数据大小满足$1≤n≤100$

输入描述:

```
输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据有多组, 如果输入为0 0则结束输入
```

输出描述:

```
输出a+b的结果
```

代码：

```c++
#include<iostream>  
using namespace std;  
  
int main()  
{  
    int m(0), n(0);  
  
    while(1)  
    {  
        cin >> m >> n;  
        if(m == 0 and n == 0)    break;  
        cout << m + n << endl;  
    }  
  
    return 0;  
}
```

## 1.4 A+B(4)

计算一系列数的和

数据范围：数据组数满足$1≤t≤100$，每组数据中整数个数满足 $1≤n≤100$  ，每组数据中的值满足 $1≤val≤100$

输入描述:

```
输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据有多组, 如果输入为0 0则结束输入
```

输出描述:

```
输出a+b的结果
```

代码：

```c++
#include<iostream>
using namespace std;  
  
int main()  
{  
    int n(0);  
    int temp(0);  
    int sum(0);  
  
    while(1)  
    {  
        cin >> n;  
        if(n == 0)    break;  
        while(n--)  
        {  
            cin >> temp;  
            sum += temp;  
        }  
                cout << sum << endl;  
        sum = 0;  
    }  
  
    return 0;  
}
```

## 1.5 A+B(5)

计算一系列数的和

数据范围：数据组数满足$1≤t≤100$，每组数据中整数个数满足 $1≤n≤100$  ，每组数据中的值满足 $1≤val≤100$

输入描述:

```
输入的第一行包括一个正整数t(1 <= t <= 100), 表示数据组数。  
接下来t行, 每行一组数据。  
每行的第一个整数为整数的个数n(1 <= n <= 100)。  
接下来n个正整数, 即需要求和的每个正整数。
```

输出描述:

```
每组数据输出求和的结果
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int t(0);
	int n(0);
	int temp(0);
	int sum(0);

	cin >> t;
	while(t--)
	{
		cin >> n;
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.6 A+B(6)

计算一系列数的和

数据范围：$1≤n≤1000$，所有数都满足 $1≤val≤1000$

输入描述:

```
输入数据有多组, 每行表示一组输入数据。
每行的第一个整数为整数的个数n(1 <= n <= 100)。
接下来n个正整数, 即需要求和的每个正整数。
```

输出描述:

```
每组数据输出求和的结果
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int n(0);
	int temp(0);
	int sum(0);

	while(cin >> n)
	{
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.7 A+B(7)

计算一系列数的和

输入描述:

```
输入数据有多组, 每行表示一组输入数据。

每行不定有n个整数，空格隔开。(1 <= n <= 100)。
```

输出描述:

```
每组数据输出求和的结果
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// 遇到空格或换行符停止
	{	
		sum += temp;
		if(getchar() == '\n')	// 读取换行符
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

## 1.8 字符串排序(1)

对输入的字符串进行排序后输出

输入描述:

```
输入有两行，第一行n
第二行是n个字符串，字符串之间用空格隔开
```

输出描述:

```
输出一行排序后的字符串，空格隔开，无结尾空格
```

代码：

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	int size(0);
	
	cin >> size;
	while(size--)
	{
		cin >> temp;
		res.emplace_back(temp);
	}
	
	sort(res.begin(), res.end());
	for(auto s : res)
		cout << s << " ";
	
	return 0;
}
```

## 1.9 字符串排序(2)

对输入的字符串进行排序后输出

输入描述:

```
多个测试用例，每个测试用例一行。
每行通过空格隔开，有n个字符，n＜100
```

输出描述:

```
对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开
```

代码：

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	
	while(cin >> temp)
	{
		res.emplace_back(temp);
		if(getchar() == '\n')
		{
			sort(res.begin(), res.end());
			for(auto s : res)
				cout << s << " ";
			cout << endl;
			
			res.clear();
		}
	}
	
	return 0;
}
```

## 1.10 字符串排序(3)

对输入的字符串进行排序后输出

输入描述:

```
多个测试用例，每个测试用例一行。
每行通过空格隔开，有n个字符，n＜100
```

输出描述:

```
对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格
```

代码：

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<sstream>
using namespace std;

int main()
{
	string s;
	
	while(getline(cin, s))
	{
		vector<string>buf;
		stringstream ss(s);
		string temp;
		while(getline(ss, temp, ','))
		{
			buf.push_back(temp);
		}
		sort(buf.begin(), buf.end());
		for(decltype(buf.size()) i = 0; i < buf.size()-1; i++)
		{
			cout << buf[i] << ",";
		}
		cout << buf.back() << endl;
		
	}
	return 0;
}
```

## 1.11 自测本地通过提交为0

每年前几场在线笔试编程题的时候，总有同学询问为什么我本地测试通过，自测也通过，提交代码系统却返回通过率0。

这不是系统的错，可能是因为：
1.你对题目理解错了，你的代码只过了样例或你自己的数据
2.你的代码逻辑有问题，你的代码只过了样例或你自己的数据

总之就是你的代码只是过了样例和自测数据，后台的测试数据你根本不可见，要多自己思考。

这个题目如果你提交后通过率为0，又觉得自己代码是正确的，可以 点击查看 通过的代码

谨记：
当你笔试的时候怀疑系统或者题目数据有问题的时候请务必先怀疑自己的代码!

当你笔试的时候怀疑系统或者题目数据有问题的时候请务必先怀疑自己的代码!

数据范围： $0<a,b<2×10^{10}$

输入描述:

```
输入有多组测试用例，每组空格隔开两个整数
```

输出描述:

```
对于每组数据输出一行两个整数的和
```

代码：

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// 遇到空格或换行符停止
	{	
		sum += temp;
		if(getchar() == '\n')	// 读取换行符
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

# 2 链表

## 2.1 删除单链表的重复节点

[面试题 02.01. 移除重复节点 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

### 2.1.1 双指针加二重循环

时间复杂度：$O(N^2)$，其中 $N$ 是给定链表中节点的数目。

空间复杂度：$O(1)$。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        ListNode* ob = head;
        while (ob != nullptr) {
            ListNode* oc = ob;
            while (oc->next != nullptr) {
                if (oc->next->val == ob->val) {
                    oc->next = oc->next->next;
                } else {
                    oc = oc->next;
                }
            }
            ob = ob->next;
        }
        return head;
    }
};
```

### 2.1.2 哈希表

时间复杂度：$O(N)$，其中$N$是给定链表中节点的数目。

空间复杂度：$O(N)$。在最坏情况下，给定链表中每个节点都不相同，哈希表中需要存储所有的$N$个值。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) 
    {
        if (head == nullptr) return head;
        unordered_set<int> occurred = {head->val};
        ListNode* pos = head;
        // 枚举前驱节点
        while (pos->next != nullptr) {
            // 当前待删除节点
            ListNode* cur = pos->next;
            if (occurred.find(cur->val) == occurred.end()) {
                occurred.insert(cur->val);
                pos = pos->next;
            } else {
                pos->next = pos->next->next;
            }
        }
        pos->next = nullptr;
        return head;
    }
};
```

## 2.2 如何找出链表的倒数第K个元素

[剑指 Offer 22. 链表中倒数第k个节点 - 力扣（Leetcode）](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 2.2.1 快慢指针法

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *p = head, *q = head; //初始化
        while(k--) {   //将 p指针移动 k 次
            p = p->next;
        }
        while(p != nullptr) {//同时移动，直到 p == nullptr
            p = p->next;
            q = q->next;
        }
        return q;
    }
};
```

### 2.2.2 暴力解法

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *temp = head;
        int size = 0;

        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size - k;
        while(size)
        {
            temp = temp->next;
            size--;
        }

        return temp;
    }
};
```

## 2.3 如何找出链表的中间节点

[876. 链表的中间结点 - 力扣（Leetcode）](https://leetcode.cn/problems/middle-of-the-linked-list/)

### 2.3.1 暴力解法

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *temp = head;
        int size = 0;

        temp = head;
        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size / 2;
        while(size)
        {
            --size;
            temp = temp->next;
        }

        return temp;
    }
};
```

### 2.3.2 快慢指针

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 2.4 反转链表（206）

[剑指 Offer 24. 反转链表 - 力扣（Leetcode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

### 2.4.1 递归

1. 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 $ret$；
2. 此后，每次函数在返回的过程中，让当前结点的下一个结点的  $next$ 指针指向当前节点；
3. 同时让当前结点的  $next$ 指针指向 $nullptr$，从而实现从链表尾部开始的局部反转；
4. 当递归函数全部出栈后，链表反转完成。

![img](figures/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;

        ListNode *current = head;
        ListNode *later = head->next;

        head = reverseList(later);
        later->next = current;
        current->next = nullptr;
        return head;
    }
};
```

### 2.4.5 双指针

1. 定义两个指针： $pre$ 和 $cur$ ；$pre$在前 $cur$在后。
2. 每次让 $pre$的 $next$ 指向 $cur$，实现一次局部反转
3. 局部反转完成之后， $pre$和 $cur$同时往前移动一个位置
4. 循环上述过程，直至 $pre$到达链表尾部

![img](figures/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = nullptr;
        ListNode *pre = head;
        
        while (pre != nullptr) {
            ListNode* t = pre->next;
            pre->next = cur;
            cur = pre;
            pre = t;
        }
        return cur;
    }
};
```

## 2.5 环形链表

[141. 环形链表 - 力扣（Leetcode）](https://leetcode.cn/problems/linked-list-cycle/)

### 2.5.1 快慢指针

时间复杂度：$O(N)$，其中 $N$是链表中的节点数。

当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。

当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 $N$ 轮。

空间复杂度：$O(1)$。我们只使用了两个指针的额外空间。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 快慢指针
        ListNode * bike = head;
        ListNode * car = head;

        // 循环内 bike 每次后移一个结点， car 每次后移 2 个结点
        // car 和 car->next 需要不为空，否则会发生非法内存访问
        // car 不为空，那么 bike 肯定也不为空
        while(car != nullptr && car->next != nullptr) 
        {
            bike = bike->next;
            car = car->next->next;

            if(car == bike) return true;
        }
        return false;
    }
};
```

### 2.5.2 哈希表

**复杂度分析**

时间复杂度：$O(N)$，其中 $N$ 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。

空间复杂度：$O(N)$，其中 $N$ 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> seen;
        while (head != nullptr) {
            if (seen.count(head)) {
                return true;
            }
            seen.insert(head);
            head = head->next;
        }
        return false;
    }
};
```

## 2.6 链表相交

[面试题 02.07. 链表相交 - 力扣（Leetcode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

### 2.6.1 双指针

复杂度分析：
时间复杂度 $O(a+b)$： 最差情况下（即 $∣a−b∣=1$， $c=0$ ），此时需遍历 $a+b$ 个节点。
空间复杂度 $O(1)$： 节点指针 A , B 使用常数大小的额外空间。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *tempA(headA), *tempB(headB);

        while(tempA != tempB)
        {
            if(tempA == nullptr)    tempA = headB;
            else    tempA = tempA->next;

            if(tempB == nullptr)    tempB = headA;
            else    tempB = tempB->next;
        }

        return tempA;
    }
};

// 更简洁一点
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};
```

## 2.7 回文链表

[234. 回文链表 - 力扣（Leetcode）](https://leetcode.cn/problems/palindrome-linked-list/)

### 2.7.1 栈

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> s;
        int size(0), i(0);
        ListNode *temp(head);

        while(temp)
        {
            s.push(temp->val);
            temp = temp->next;
            ++size;
        }

        temp = head;
        while(temp)
        {
            if(temp->val != s.top())    return false;
            temp = temp->next;
            s.pop();
            ++i;
            if(i == size / 2)   return true;
        }

        return true;
    }
};
```

### 2.7.2 快慢指针

破坏了原链表的结构。

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head || !head->next)
            return 1;
        ListNode *fast = head, *slow = head;
        ListNode *p, *pre = NULL;
        while(fast && fast->next){
            p = slow;
            slow = slow->next;    //快慢遍历
            fast = fast->next->next;

            p->next = pre;  //翻转
            pre = p;
        }
        if(fast)  //奇数个节点时跳过中间节点
            slow = slow->next;

        while(p){       //前半部分和后半部分比较
            if(p->val != slow->val)
                return 0;
            p = p->next;
            slow = slow->next;
        }
        return 1;
    }
};
```

## 2.8 合并两个有序链表（21）

[21. 合并两个有序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

### 2.8.1 迭代

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *list = new ListNode(0);
        ListNode *next = list;

        while(list1 && list2)
        {
            if(list1->val <= list2->val)
            {
                next->next = list1;
                list1 = list1->next;
            }
            else
            {
                next->next = list2;
                list2 = list2->next;
            }
            next = next->next;
        }

        // l1 或 l2 可能还有剩余结点没有合并， 
        // 由于从上面的 while 循环中退出， 那么链表 l1 和 l2 至少有一个已经遍历结束
        if(list1 != nullptr) next->next = list1;
        if(list2 != nullptr) next->next = list2;
        
        return list->next;
    }
};
```

### 2.8.2 递归

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
            return l2;
        }
        if (l2 == NULL) {
            return l1;
        }
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
};
```

# 3 数组

## 3.1 最大子数组和（53）

[53. 最大子数组和 - 力扣（Leetcode）](https://leetcode.cn/problems/maximum-subarray/)

### 3.1.1 暴力解法

时间复杂度：$O(N^2)$

空间复杂度：$O(1)$

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum(INT_MIN);
        int temp(0);

        for(int i = 0; i < nums.size(); ++i)
        {
            for(int j = i; j < nums.size(); ++j)
            {
                temp += nums.at(j);
                sum = sum > temp ? sum : temp;
            }
            temp = 0;
        }

        return sum;
    }
};
```

### 3.1.2 分治

1. 取数组中心点为中心；
2. 最大子序要么全在中心左边，要么在右边，要么跨中心；
3. 分三种情况进行考虑 跨中心的情况，再分治成中心点左侧和右侧的最大子序和问题。

时间复杂度：$O(Nlog(N))$

空间复杂度：$O(log(N))$

![image-20230510093433295](figures/image-20230510093433295.png)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        return maxSubArrayHelper(nums, 0, nums.size() - 1);
    }

    int maxSubArrayHelper(vector<int>& nums, int left, int right)
    {
        if(left == right)   return nums[left];

        int center = (left + right) / 2;
        int leftMax = maxSubArrayHelper(nums, left, center);
        int rightMax = maxSubArrayHelper(nums, center + 1, right);

        int leftCrossMax = INT_MIN; // 初始化一个值
        int leftCrossSum = 0;
        for (int i = center ; i >= left ; i --) 
        {
            leftCrossSum += nums[i];
            leftCrossMax = max(leftCrossSum, leftCrossMax);
        }

        // 计算包含右侧子序列最后一个元素的子序列最大值
        int rightCrossMax = nums[center + 1];
        int rightCrossSum = 0;
        for (int i = center + 1; i <= right ; i ++) 
        {
            rightCrossSum += nums[i];
            rightCrossMax = max(rightCrossSum, rightCrossMax);
        }
        
        int crossMax = leftCrossMax + rightCrossMax;
        return max(crossMax, max(leftMax, rightMax));
    }
};
```

### 3.1.3 贪心法

时间复杂度：$O(N)$

空间复杂度：$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        int result = INT_MIN;
        int numsSize = int(nums.size());
        int sum = 0;
        for (int i = 0; i < numsSize; i++)
        {
            sum += nums[i];
            result = max(result, sum);
            //如果sum < 0，重新开始找子序串
            if (sum < 0)
            {
                sum = 0;
            }
        }

        return result;
    }
};
```

### 3.1.4 动态规划

时间复杂度：$O(N)$

空间复杂度：$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        int result = INT_MIN;
        int numsSize = int(nums.size());

        int sum = nums[0];
        result = nums[0];
        for (int i = 1; i < numsSize; i++)
        {
            sum = max(sum + nums[i], nums[i]);
            result = max(result, sum);
        }

        return result;
    }
};
```

## 3.2 原地移除元素（27）

[27. 移除元素 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-element/)

### 3.2.1 通用解法（双指针）

时间复杂度：$O(N)$

空间复杂度：$O(1)$

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;

        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != val)
            {
                nums[slow++] = nums[i];
            }
        }

        return slow;
    }
};
```

### 3.2.2 优化后的双指针

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size();
        while (left < right) {
            if (nums[left] == val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    }
};
```

## 3.3 合并两个有序数组（88）

[88. 合并两个有序数组 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-sorted-array/)

### 3.3.1 STL库

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i = 0; i < n; ++i)  nums1[m + i] = nums2[i];
        sort(nums1.begin(), nums1.begin() + m + n);
    }
};
```

### 3.3.2 从后面开始确定

时间复杂度：$O(M+N)$

空间复杂度：$O(1)$

如果两个数组从结尾向开头（数字从大到小）进行比较，那么每次把比较之后的数字放置到 nums1 中的后面，由于后面的数字本身就是提供出来的多余的位置，都是 0，因此不需要对 nums1 进行移动。

1. 当 $m > 0$ 并且 $n > 0 $ 时，从后向前比较  $num1[m−1]$ 和  $nums2[n−1] $ ：
   - 如果是  $nums1[m−1]$ 大，则把   $num1[m−1]$ 放到 $num1$ 的第 $m+n−1$ 位置，并让 $m-=1$。
   - 如果是 $nums2[n−1] $ 大，则把 $nums2[n−1]$ 放到 $num1$ 的第 $m+n−1$ 位置，并让 $n-=1$。
2. 当上面的遍历条件结束的时候，此时 m 和 n 至少有一个为 0。
   - 当 $m == 0$ 时，说明 num1 的数字恰好用完了，此时 nums2 可能还剩元素，需要复制到 nums1 的头部；
   - 当 $n == 0$ 时，说明 num2 的数字恰好用完了，此时 nums1 可能还剩元素，由于剩余的这些元素一定是 nums1 和 nums2 中最小的元素，所以不用动，直接留在原地就行。

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int k = m + n - 1;
        while (m > 0 && n > 0) {
            if (nums1[m - 1] > nums2[n - 1]) {
                nums1[k] = nums1[m - 1];
                m --;
            } else {
                nums1[k] = nums2[n - 1];
                n --;
            }
            k --;
        }
        for (int i = 0; i < n; ++i) {
            nums1[i] = nums2[i];
        }
    }
};
```

### 3.3.3 从前面开始确定（归并排序）

时间复杂度：$O(M+N)$

空间复杂度：$O(M+N)$

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {   
        vector<int> temp(nums1);       //初始化m为nums1的拷贝
        int i = 0, j = 0, k = 0;

        while(i <= m-1 && j <= n-1)
        {
            if(temp[i] < nums2[j])                nums1[k++] = temp[i++];
            else               nums1[k++] = nums2[j++];
        }
        while(i <= m-1)         
        {
            nums1[n+i] = temp[i];
            i++;
        }
         while(j <= n-1)
        {
            nums1[m+j] = nums2[j];
            j++;
        }

    }
};
```

## 3.4 查找共用字符（1002）

[1002. 查找共用字符 - 力扣（Leetcode）](https://leetcode.cn/problems/find-common-characters/)

### 3.4.1 利用数组求解

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> out;
        int num[100][26]={0};                  //建立一个二维数组，标记所有出现的字母次数
        for(int i =0;i<A.size() ;i++)
            for(int j=0;j<A[i].size();j++)
                num[i][(A[i][j]-'a')]++;
        
        for(int j=0;j<26;j++)                  //将所有列的最小值存到第一行
            for(int i=1;i<A.size();i++)
                num[0][j] = min (num[0][j],num[i][j]);
                    
        string str;                           //按照第一行保存的次数输出相应字母
        for(int i=0;i<26;i++){
            while(num[0][i]--)
            {
                str.clear();
                str.push_back((char)('a'+i));
                out.push_back(str);
            }
        }
        return out;
    }
};

```

### 3.4.2 哈希

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> res;
        vector<unordered_map<char,int>> vum(A.size());
        for(int i = 0;i < A.size();++i)
            for(auto c : A[i])
                vum[i][c]++;
        for(auto pair : vum[0])
        {
            int n = pair.second;
            for(int i = 1;i < vum.size();++i)
                n = min(n,vum[i][pair.first]);
            while(n--) res.push_back(string(1,pair.first));       
        }
        return res;
    }
};
```

